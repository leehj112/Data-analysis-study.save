# -*- coding: utf-8 -*-
"""(part2)Data-study1.py

Automatically generated by Colab.

Original file is located at
 
"""

# 구글 연동 ==> colab
# 구글 드라이브 마운트
from google.colab import drive
drive.mount('/gdrive/')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

drive_path = "/gdrive/My Drive/"

train = pd.read_csv(drive_path + "titanic/train.csv")
test = pd.read_csv(drive_path + "titanic/test.csv")
submission = pd.read_csv(drive_path + "titanic/submission.csv")

print(train.shape, test.shape, submission.shape)
# titanic 불러오기

train.head(3)
# train data check

test.head(2)
# test data check

submission.head()
# submission data check

train.info()

train.describe(include='all')
# train 데이터프레임 통계 정보

# 결측값 확인
import missingno as msno
msno.bar(train, figsize=(10,5), color=(0.7,0.2,0.2))
plt.show()

msno.matrix(test, figsize=(10, 5), color=(0.7, 0.2, 0.2))
plt.show()

# 데이터 결합
# TrainSplit 열을 추가, Train, Test를 값으로 지정
train['TrainSplit'] = 'Train'
test['TrainSplit'] = 'Test'
data = pd.concat([train, test], axis=0)
print(data.shape)

# 숫자형 피처 추출
data_num = data.loc[:, ['Pclass', 'Age', 'SibSp', 'Parch', 'Fare', 'Survived']]

# 결측값 대체
data_num['Age'] = data_num['Age'].fillna(data_num['Age'].mean())
data_num['Fare'] = data_num['Fare'].fillna(data_num['Fare'].mode()[0])

# 학습용 데이터와 예측 대상인 테스트 데이터 구분
selected_features = ['Pclass', 'Age', 'SibSp', 'Parch', 'Fare']

X_train = data_num.loc[data['TrainSplit']=='Train', selected_features]
y_train = data_num.loc[data['TrainSplit']=='Train', 'Survived']

X_test = data_num.loc[data['TrainSplit']=='Test', selected_features]

print("Train 데이터셋 크기: ", X_train.shape, y_train.shape)
print("Test 데이터셋 크기: ", X_test.shape)

# 훈련 - 검증 데이터 분할
from sklearn.model_selection import train_test_split
X_tr, X_val, y_tr, y_val =  train_test_split(X_train, y_train, test_size=0.2,
                                             shuffle=True, random_state=20)

# 로지스틱 회귀 모델
from sklearn.linear_model import LogisticRegression
lr_model = LogisticRegression()
lr_model.fit(X_tr, y_tr)
y_val_pred = lr_model.predict(X_val)

# 실제값과 예측값과 비교하여 혼동 행열을 계산
# Confusion Matrix
from sklearn.metrics import confusion_matrix
sns.heatmap(confusion_matrix(y_val, y_val_pred), annot=True, cbar=False, square=True)
plt.show()

# 평가 지표
from sklearn.metrics import accuracy_score, precision_score, recall_score
from sklearn.metrics import f1_score, roc_auc_score
print("Accuracy: %.4f" % accuracy_score(y_val, y_val_pred))
print("Precision: %.4f" % precision_score(y_val, y_val_pred))
print("Recall: %.4f" % recall_score(y_val, y_val_pred))
print("F1: %.4f" % f1_score(y_val, y_val_pred))
print("AUC: %.4f" % roc_auc_score(y_val, y_val_pred))
# 최대값은 1이며 예측력이 좋은 모델일 수록 1에 가까운값을 갖는다.

# test 데이터에 대한 예측값 정리
y_test_pred = lr_model.predict(X_test)


submission['Survived'] = y_test_pred.astype(int)

submission_filepath = drive_path + 'baseline_num_lr_submission_001.csv'
submission.to_csv(submission_filepath, index=False)
submission.head(5)

# 피처 엔지니어링
train['Survived'].value_counts(dropna=False)
# 생존자 342명 check --> 1

sns.countplot(x='Survived',data=data[data['TrainSplit']=='Train'])
plt.show()
# TrainSplit 열을 이용하여 train 데이터만 따로 추출하여 적용

# Pclass: 객실 등급
sns.countplot(x='Pclass', hue='TrainSplit', data=data)
plt.show()

sns.countplot(x='Pclass',hue='Survived',data=data[data['TrainSplit']=='Train'])
plt.show()

# barplot 함수를 사용하여 등급별 객실 요금위 중간값 분포
sns.barplot(x='Pclass',y='Fare', hue = 'Survived',
            data=data[data['TrainSplit']=='Train'], estimator=np.median)
plt.show()

# histplot 함수의 multriple옵션을 조정하는 방법
sns.histplot(x='Sex', hue='Survived', multiple='dodge',
             data=data[data['TrainSplit']=='Train'])
plt.show()

sns.histplot(x='Sex', hue='Survived', multiple='stack',
            data=data[data['TrainSplit']=='Train'])
plt.show()

data.loc[data['Sex']=='female','Sex'] = 0
data.loc[data['Sex']=='male','Sex'] = 1
data['Sex'] = data['Sex'].astype(int)

data['Sex'].value_counts(dropna=False)
# female 0, male 1

# Name 열 문자열 데이터 확인
data['Name'].unique()

# Name 열을 선택 str속성을 적용하여 문자열을 직접 추출
# split 메소드를 적용하면
title_name =data['Name'].str.split(", ", expand=True)[1]
title_name

title = title_name.str.split(".", expand=True)[0]
title.value_counts(dropna=False)

# replace 함수를 타이틀이 들어 있는 시리즈 객체에 적용하면 리스트 안의 문자열 뒤에 나오는 문자열로 모두 바꾼다.
title = title.replace(['Ms'], 'Miss')
title = title.replace(['Mlle', 'the Countess', 'Lady', 'Don', 'Dona', 'Mme', 'Sir', 'Jonkheer'], 'Noble')
title = title.replace(['Col', 'Major', 'Capt'], 'Officer')
title = title.replace(['Dr', 'Rev'], 'Priest')
data['Title'] = np.array(title)
data['Title'].value_counts(dropna=False)

#결측값 확인 및 대체
# Age 열의 결측값을 확인
# 같은 타이틀을 갖는 승객끼리 그룹을 나누고, 그룹별 승객 나이의 중간값으로 결측값을 대처, fillna 메소드 사용
for title in data['Title'].unique():
    # 결측값 개수 확인
    print("%s 결측값 개수: " % title, data.loc[data['Title']==title, 'Age'].isnull().sum())
    # 각 Title의 중앙값으로 대체
    age_med = data.loc[data['Title']==title, 'Age'].median()
    data.loc[data['Title']==title, 'Age'] = data.loc[data['Title']==title, 'Age'].fillna(age_med)

# 결측값 처리 여부 확인
print("\n")
print("Age 열의 결측값 개수: ", data['Age'].isnull().sum())

# displot의 kind 옵셥을 hist로 지정
# hue에 속성에 따라 생존자 구분

sns.displot(x='Age',kind='hist', hue='Survived',
            data=data[data['TrainSplit']=='Train'])

plt.show()

# Age 분포
sns.displot(x='Age', kind='hist', hue='Survived',
            data=data[data['TrainSplit']=='Train'])
plt.show()

